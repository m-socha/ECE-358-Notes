\documentclass[12pt,titlepage]{article}
\usepackage[margin=1in]{geometry}

\begin{document}
  \begin{titlepage}
    \vspace*{\fill}
    \centering

    \textbf{\Huge ECE 358 Course Notes} \\ [0.4em]
    \textbf{\Large Computer Networks} \\ [1em]
    \textbf{\Large Michael Socha} \\ [1em]
    \textbf{\large 4A Software Engineering} \\
    \textbf{\large University of Waterloo} \\
    \textbf{\large Spring 2018} \\
    \vspace*{\fill}
  \end{titlepage}

  \newpage 

  \tableofcontents

  \newpage

  \section{Course Overview}
    \subsection{Logistics}
      \begin{itemize}
        \item \textbf{Professor:} Albert Wasef
        \item \textbf{Email:} awasef@uwaterloo.ca
        \item \textbf{Phone:} ext. 31723
        \item \textbf{Office:} EIT-4012
      \end{itemize}

    \subsection{Topics Covered}
      This course focuses on the fundamentals of networking and thinking like a network engineer.
      Specific topics covered by this course include:
      \begin{itemize}
        \item LAN technologies and underlying protocols
        \item Transport protocols (TCP, retransmission)
        \item IP layer concepts (e.g. routing, addressing)
        \item Discrete-event simulation
        \item Network utilities
      \end{itemize}

  \section{Introduction - Computer Networks and the Internet}
    \subsection{What is the Internet?}
      The Internet is the world's largest computer network, connecting billions of devices. Devices
      connected to the Internet are known as hosts (end systems), and are running some kinds of network applications.
      Communication links are necessary for hosts to share information with each other, which can be done through
      a variety of means, including cables (e.g. fiber, copper), radio, or satellite. Packet switches (e.g. routers,
      switches) are responsible for forwarding chunks of data through these communication links.

      Standardized protocols are necessary for communication between hosts. Protocols define the format and order of
      messages sent as well as actions taken upon message transmission and reception. Sample protocols include TCP, IP, and HTTP.
      These standards are maintained by the IEFT (Internet Engineering Task Force).

      The Internet can also be viewed from a more service-oriented perspective, since it can be used to provide
      services such as the Web, VoIP, email, etc. to applications. The Internet also provides a programming interface
      to applications to interact with connected hosts.

    \subsection{Network Edges}
      Edge devices provide some sort of entry point to a network. Examples include computers, mobile devices, and servers
      (often in data centers). Communication between devices on a network can be wired or wireless.

      End systems can connect to an edge router through various ways, including using residential access nets, institutional
      access networks and mobile access networks. Important considerations in such connections include a connection's bandwidth,
      latency, and whether it is shared/dedicated.

      Network connections can be made through a digital subscriber line (DSL), which allows for the transmission of data over
      telephone lines. A digital subscriber line access multiplexer (DSLAM) can be used to connect multiple DSL lines to a digital
      communications channel. Downstream transmission rates (typically < 1 Mbps) tend to be much faster than upstream transmission
      rates (typically < 10 Mbps). Optimal transmission rates are rarely reached in practice. Each line connects directly to a
      central office.

      Network connections can also be made through a cable network, which uses the same infrastructure as cable television.
      Differing frequencies are used to distinguish between different channels of communication. Hybrid Coaxial Cables (HFCs) are
      used to form the connection, which tend to have a downstream transmission around 30 Mbps and an upstream transmission around
      2 Mbps. These connections attach to an ISP router, and multiple parties typically share access to a cable headend.

      Most enterprise access networks use Ethernet connections, which tend to be much faster (available speeds include 10 Mbps, 100 Mbps,
      1 Gbps, 10 Gbps). Nowadays, most end systems connect to an Ethernet switch.

      Wireless access networks can connect end systems to routers without a cable connection. Wireless LANs (i.e. Wi-Fi) provide network
      access for a fairly small range, while wide-area access networks are provided by cellular operators and have a range of 10s of
      kilometers. Wireless LANs tend to have higher bandwidths than wide-area access networks.

      A host sending function is responsible for:
        \begin{itemize}
          \item Taking an application message
          \item Breaking the message into chunks (packets) or length $L$ bits
          \item Transmitting packets across a network at transmission rate $R$
        \end{itemize}
      $packet transmission delay = \frac{L}{R}$

      The medium facilitating transmission between a transmitter and receiver is called a physical link. Physical links may be guided
      (i.e. solid cables, such as copper, fiber or coax), or unguided (i.e. signals may propagate freely, such as through radio).

      Coaxial cables are formed from two concentric copper conductors. Coaxial cables bidirectional and they are are broadband, so they
      can support communication across multiple channels.

      Fiber optic cables feature a glass fiber carrying light pulses, where each pulse represents one bit. Fiber optics cables support
      high-speed point-to-point transmission, and have a low error rate.

      Radio is a wireless bidirectional signal carried in the electromagnetic spectrum. The environment of propagation may cause signal
      reflection, obstruction (by objects in path) and interference. Radio link network types include terrestrial microwaves, LAN, wide-area
      and satellite.

    \subsection{Network Core}
      Through store-and-forward packet-switching, an entire packet must arrive at a router before it can be transmitted on the next link. The
      resulting end-end delay is $\frac{2L}{R}$ (plus any propagation delay).

      Should the arrival rate exceed a link's transmission rate, the resulting packets will queue up. If the memory in which the packets are
      stored fills up, packets can be dropped.

      Routing determines the source-destination route taken by packets, while forwarding moves packets to the appropriate output router.

      Circuit switching is an alternative design for a network core. Instead of queuing up packets along shared lines, end-end resources
      between a transmission's source and destination are reserved (i.e. circuitry used only for that specific transmission). Such an approach
      is commonly used in telephone networks. Circuit switching can be implemented using FDM (frequency-division multiplexing) or TDM
      (time-division multiplexing).

      Packet switching tends to be preferable to circuit switching for bursty data. Moreover, packet switching is supports resource sharing,
      and the setup for calls is simpler than that of circuit switching. However, packet switching may have excessive congestion, resulting
      in packet delay and loss. Providing circuit-like behaviour (i.e. guaranteed bandwidth) to packet switching networks remains an unsolved
      problem.

      End systems typically connect to the Internet through access Internet Service Providers (ISPs). Since competing ISPs exist, they must be
      connected to one another as well to effectively send packets to one another. These connections are implemented using Internet Exchange
      Points (IXPs). Moreover, some content providers may setup their own networks (content provider networks) to connect their data centers to the Internet,
      often bypassing regional ISPs. The resulting Internet network structure is quite complex, with its evolution having been driven by a
      combination of business and politics.

    \subsection{Delay, Loss and Throughput}
      \subsubsection{Sources of Packet Delay}
        $$d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}$$
      
        \paragraph{Nodal processing} includes the time to check bit errors and determine the output link. This time is usually 10-1000us.

        \paragraph{Queuing delay} is the time spent waiting at the output link for transmission.

        \paragraph{Transmission delay} $\frac{L}{R}$

        \paragraph{Propagation delay} $d/s$, where $d$ is the length of the physical link and $s$ is the propagation speed.

      \subsubsection{Queuing Delay}
        Let $R$ be the link bandwidth, $L$ be the packet length, and $a$ be the average package arrival rate. The average queuing delay
        can be measured using $\frac{La}{R}$. If this value is close to 0, the queuing delay is small. Once the value exceeds 1, more
        packets are arriving than can be serviced, and the queuing delay may be infinite. Should packets be dropped, they may be
        re-transmitted by a previous node in the network, but this is not guaranteed.

      \subsubsection{Measuring Delay and Loss}
        The traceroute program can be used to measure the delay and loss on a network. It works by sending some test packets to a router which
        then returns the packets towards the sender.

      \subsubsection{Throughput}
        Throughput is the rate (bits/sec) at which bits are transferred between a sender and a receiver. Throughput can be measured as instantaneous
        (rate at a single point in time) or average (rate over a period of time). A bottleneck link is a link on an end-to-end path that constrains
        end-to-end throughput. For example, if one link on a network has a throughput of 20Mbps and another has a throughput of 50Mpbs, then the
        bottleneck link is the 20Mpbs link.

    \subsection{Protocol Layers and Service Models}
      \subsubsection{Protocol Layers}
        Each layer implements some sort of service, and may rely on services provided by the layer below. Layering helps simplify dealing with
        complex systems. In particular, a layering system helps in identification of a system's components and developing a model of how different
        components interact. Layering also allows for a modular design, which eases maintenance and updating processes.

      \subsubsection{Open System Interconnection (OSI) Model}
        OSI is a conceptual model describing the layers of telecommunication or computing systems. The OSI layers are:
        \begin{itemize}
          \item \textbf{Application:} Supports network applications
          \item \textbf{Presentation:} Allows applications to interpret meanings of data (e.g. for encryption, compression)
          \item \textbf{Session:} Synchronization, checkpointing and recovery of data (i.e. controls connection between computers)
          \item \textbf{Transport:} Provides process-process data transfer
          \item \textbf{Network:} Handles routing from source to destination
          \item \textbf{Link:} Provides data transfer between directly connected nodes
          \item \textbf{Physical:} Deals with physical specs of connection
        \end{itemize}

      \subsection{Security}
        The field of network security deals with how computer networks can be attacked, defending against such attacks and architectures
        that minimize the risk of attacks. Internet technologies were not designed at first with much security in mind, though security
        considerations have since been added across all networking layers.

      \subsubsection{Types of Transmission}
        \begin{itemize}
          \item \textbf{Virus:} Self-replicating infection started by opening/executing object
          \item \textbf{Worm:} Self-replicating infection started by passively receiving object
        \end{itemize}

      \subsubsection{Examples of Attack}
        \begin{itemize}
          \item \textbf{Spyware:} Records user action (e.g. keystrokes, websites visited)
          \item \textbf{Botnet:} A collection of infected hosts running bots that can be used for spam, distributed denial of service (DDoS attacks), etc.
          \item \textbf{Denial of Service (DoS):} An attack where network resources (e.g. bandwidth) become unavailable to legitimate traffic due to the
          introduction of large amounts of bogus traffic. A distributed denial of service (DDos attack) performs a DoS attack using a collection of hosts.
          \item \textbf{Packet Sniffing} Promiscuous network connections having their data read by a third party as it passes by
          \item \textbf{IP Address Spoofing} Packets being send from a false source IP address, which can be used to hide one's identity or impersonate another host
        \end{itemize}

  \section{Application Layer}
    \subsection{Network Application Introduction}
      Networks apps are designed to run on end systems, and use the network to communicate with other hosts. An example is a Web application, where the involved network
      apps are the browser running on the user host and the Web server program running in the Web server host. These network apps are only designed for end systems;
      network-core devices function on layers below the application layer.

    \subsection{Network Application Architectures}
      \subsubsection{Network Application Architectures}
        A client-server architecture features an always-on host, called the server, which services requests from many user hosts, known as clients. Servers respond to
        client requests by returning requested data to them. Clients only communicate with the web server, and not between each other. A server has a permanent IP addresses,
        while clients may have dynamic IP addresses.

      \subsubsection{Peer-to-Peer (P2P) Architecture}
        P2P networks don't feature an always-on server, but rather a collection of end systems that may communicate directly with one another; peers can request services
        from and provide services to other peers. These systems are self-scalable, with new peers being able to bring both new service capacity and new service demands. This
        type of architecture poses many challenges related to management and security.

    \subsection{Process Communication}
      A process is a program running within a host. If multiple processes run within the same host, they can communicate through inter-process communication procedures defined
      by the underlying OS. To communicate between hosts, processes need to exchange messages with one another.
      \subsubsection{Client vs Server Processes}
        Client processes run on client hosts, where they initiate communication. Server processes run on server hosts, where they wait to be contacted to server client requests.
        In a P2P architecture, hosts may need to run both client and server processes.

    \subsection{Sockets}
      A host sends and receives messages on a network through a software interface called a socket, serving as the interface between the application and transport layer. Sockets
      are sometimes referred to as the API between an application and network.

    \subsection{Addressing Processes}
      In order to send a message across a network to a destination host, the address of that host and an identifier that specifies the receiving process (socket) must be provided.
      A host is identified by its IP address, while its socket is identified by a port number. Popular applications are linked to specific port numbers (e.g. Web server has port
      number 80).

    \subsection{App-layer protocols}
      An application-layer protocol is responsible for defining the following:
      \begin{itemize}
        \item Types of messages exchanges (e.g. request, response)
        \item Message syntax
        \item Message semantics
        \item Rules for when and how processes send and response to messages
      \end{itemize}
      App-layer protocols may be open (e.g. HTTP, SMTP) or may be proprietary (e.g. Skype)

    \subsection{Transport Services}
      Candidate transport services can be evaluated along four main dimensions:

      \subsubsection{Data Integrity / Reliable Data Transfer}
        A protocol that guarantees that data sent between applications is delivered correctly and completely is said to provide reliable data transfer. Loss-tolerant applications
        (e.g. multimedia) do not require perfect data integrity.

      \subsubsection{Throughput}
        Applications that require a certain level of throughput to function correctly (e.g. multimedia) are described as bandwidth-sensitive. Applications that do not have strict
        throughput requirements are described as elastic.

      \subsubsection{Timing}
        Some applications (e.g. real-time chat, multiplayer games) may not function well if the time to communicate between source and destination applications exceeds a certain
        amount of time.

      \subsubsection{Security}
        Examples of security-related features a transport service can provide include encryption, enforcing authentication or ensuring data integrity.

    \subsection{Transport Services Provided by the Internet}
      The Internet makes two transport protocols available, namely TCP and UDP

      \subsubsection{TCP}
        TCP is a connection-oriented protocol, meaning that the client and server exchange transport-layer control info before application messages are exchanged. When the
        application finishes sending messages, it must tear down this connection. TCP also provides reliable data transfer. Also, for the welfare of the Internet in general
        rather than specific applications, TCP provides a congestion-control mechanism, which throttles sending processes when the network between the client and server
        is congested. Flow control is also provided.

        \subsubsection{Securing TCP}
          Neither TCP or UDP provide any encryption. To remedy this issue, an enhancement for TCP, known as Secure Sockets Layer (SSL), can be used to provide process-to-process
          security services, including encryption, data integrity and end-point authentication.

      \subsubsection{UDP}
        UDP is a lightweight transport protocol. Unlike TCP, UDP is not connection-oriented, and does not provide reliable data transfer. Also, UDP does not provide a
        congestion-control mechanism.

    \subsection{HTTP Overview}
      HyperText Transfer Protocol (HTTP) is the Web's main application-layer protocol. HTTP can be used to load web pages, which consist of objects than can include HTML files,
      image files, Java applets, etc.. Most Web pages consist of a base HTML file that references other objects. Each object is addressable by a Uniform Resource Locator (URL),
      which includes a host name and a path name.

      HTTP uses TCP as its underlying transport protocol. HTTP clients (e.g. Web browsers) are responsible for initiating a TCP connection with a server, after which the two hosts
      can exchange messages through their socket interface. HTTP is considered to be a stateless protocol, meaning that HTTP servers are not required to maintain information about
      past client requests.

    \subsection{HTTP Connections}

      \subsubsection{Non-Persistent Connections}
        In non-persistent HTTP connections, at most one object is sent over each connection, after which the connection is closed and a new one must be established. These types of
        connections have significant overhead, with TCP connection variables having to be stored on both the client and webserver, and each object suffering from a delivery delay
        of 2 Round-Trip Times (RTTs).

      \subsubsection{Persistent Connections}
        Persistent HTTP connections allow for a multiple objects from the same host to be sent over a single connection. Therefore, it is possible to have as few as one RTT of
        overhead for all objects on a server. This connection remains open until a configurable timeout interval, after which it is closed. The default mode of HTTP makes use
        of persistent connections.

    \subsection{HTTP Messages}

      \subsubsection{Requests}
        Common request types:
        \begin{itemize}
          \item \textbf{GET:} Used to request an object, with the requested object identified in the URL (most common type of request)
          \item \textbf{POST:} Used to submit a request with an entity body (e.g. to submit data from a filled out form)
          \item \textbf{HEAD:} Similar to get, but leaves out the requested object
          \item \textbf{PUT:} Used to upload an object to a specific path
          \item \textbf{DELETE:} Used to delete an object on a specific path
        \end{itemize}

      \subsubsection{Responses}
        Common response codes:
        \begin{itemize}
          \item \textbf{200 OK:} Request succeeded, requested object later in this message.
          \item \textbf{301 Moved Permanently:} Resource has been moved, new URL in Location: header of this message.
          \item \textbf{400 Bad Request:} Request message not understood by server.
          \item \textbf{404 Not Found:} Requested object not found on server.
          \item \textbf{505 HTTP Version Not Supported:} HTTP protocol version not supported by server.
        \end{itemize}

    \subsection{Cookies}
      Although HTTP servers are stateless, it is often useful to be able to identify users, which can be done using cookies. Cookies technology has 4 components, namely:
      \begin{enumerate}
        \item Cookie header line in HTTP response message
        \item Cookie header line in HTTP request message
        \item Cookie stored on user end system
        \item Backend database on website index by cookies
      \end{enumerate}
      The key idea behind cookies it that they can be assigned to users when they first visit a website, after which the user can be identified because they include the
      cookie in their HTTP requests. Sample uses of cookies include authorization and saving user state and settings.

    \subsection{Web Caching}
      The goal of web caches (also known as proxy servers) is to satisfy a client request without involving the origin server. Instead, a client sends messages to a proxy
      that either already cached the results, in which case it responds to the request, or does not have the result, in which it sends a request to the origin server. Note
      that the proxy is acting as both a server and a client.

      The main benefits of web caching are reducing response time (effective when client has high-speed connection to cache) and by reducing traffic. Caches are typically
      installed by an ISP (e.g. a university might install a cache and configure all clients to point to it).

    \subsection{Conditional GET}
      A conditional GET can be used by web caches to ensure they are not returning state data. Conditional GETs use GET requests but include an If-modified-since: header.

    \subsection{DNS: Domain Name System}
      DNS serves to provide a mapping between host names and their IP addresses. DNS implements this through a distributed database implemented in a hierarchy of servers
      known as name servers. DNS is used by the application layer, where hosts communicate with a DNS server to resolve names, and can then proceed with the request.

      DNS services include:
      \begin{itemize}
        \item Hostname to IP translation
        \item Host aliasing
        \item Mail server aliasing
        \item Load distribution (i.e. cycling through replicated web servers to avoid overloading a single one)
      \end{itemize}

      Although a single centralized DNS may sound like an appealing idea, it would face many problems, including:
      \begin{itemize}
        \item Single point of failure - DNS server going down would make the Internet unusable
        \item Huge traffic volume to a single server
        \item Server would be physically distant from most users
        \item Maintenance concerns - the DNS database would be huge and would require very frequent updates
      \end{itemize}

    \subsubsection{Server Classes}
      \begin{itemize}
        \item \textbf{Root name servers} are contacted by local name server if the name cannot be resolved. Root name servers may contact servers lower on the hierarchy in
        resolving the name.
        \item \textbf{Top-level domain (TLD) servers} are responsible for top-level domains such as com, org, net, and country top-level domains.
        \item \textbf{Authoritative DNS Servers} are an organization's own DNS servers, providing authoritative hostname to IP mappings for their named hosts. These servers
        can be maintained by an organization itself or by a service provider.
        \item \textbf{Local DNS Name Servers} (also known as default name servers) serve as local proxies to DNS requests provided by an ISP. Local DNS Name Servers store
        a cache of name-to-address translation pairs, and in the case of a cache miss, are able to forward a request into the DNS hierarchy. Once forwarded into the DNS hierarchy,
        querying can be iterative (each server returns the next server to query to the local DNS server), or recursive (The root DNS server initiates a series of calls down the
        server hierarchy and ultimately returns the resolved name).
      \end{itemize}

    \subsubsection{DNS Records}
      DNS servers store resource records (RRs), including RRs that map hostnames to IPs. An RR contains the following fields: (Name, Value, Tpe, TTL (time-to-live)).
      The record types are as follows:
      \begin{itemize}
        \item \textbf{Type=A} Name is hostname and Value is IP address.
        \item \textbf{Type=NS} Name is domain and Value is host-name of authoritative DNS server that can option IP address for hosts in the domain.
        \item \textbf{Type=CNAME} Name is alias and Value is the corresponding canonical hostname.
        \item \textbf{Type=MX} Name is alias and Value is the corresponding mail server.
      \end{itemize}

    \subsubsection{DNS Messages}
      Query and reply are the only kinds of DNS messages. The parts of a message are described below:
      \begin{itemize}
        \item \textbf{Header:} Contains message identifier, which is copied from a query into its reply. The header also includes a number of flags, including one for
        query or reply, whether recursion is desired, whether recursion is available, and whether the reply is authoritative.
        \item \textbf{Questions:} Includes name and type field for a query.
        \item \textbf{Answers:} Contains records that were queried for.
        \item \textbf{Authority:} Contains records of other authoritative servers.
        \item \textbf{Additional:} Additional info (e.g. for a Type MX reply, this contains the Type A record for the canonical hostname of the mail server).
      \end{itemize}

    \subsubsection{Inserting Records into DNS Database}
      Domain names can be registered at commercial entities called registrars. Once the domain is confirmed to be available, a Type A DNS record and a Type MX DNS
      record are inserted.

    \subsubsection{DNS Vulnerabilities}
      DDoS attacks against root servers are generally ineffective, since root servers have packet filters, and even if they do go down, most local DNS servers store the IPs of
      TLD servers.

      A potentially more dangerous line of attack would be to DDoS TLD servers. However, even if TLD servers go down, the impact of the outage would be mitigated
      by caching in local DNS servers.

      Other potential lines of attack include man-in-the-middle attacks, in which DNS queries from hosts are intercepted and bogus replies returned,
      and DNS poisoning, where bogus replies are sent to a DNS server to fill its cache with incorrect records. DNS infrastructure can also be used to launch a DDoS attack by sending
      DNS queries with a spoofed source of the attack target to many authoritative servers, with to queries designed so that their response is larger than the original query (i.e. the
      attacker's DoS efforts get amplified).

\end{document}
